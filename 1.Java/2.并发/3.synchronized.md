#### 1.synchronized: 一种互斥锁，一次只能允许一个线程进入被锁住的代码块

1. 如果synchronized修饰的是实例方法，对于锁的是对象实例
2. 如果修饰的是静态方法，对应锁则是当前类的Class实例
3. 如果修饰的是代码块，对应的锁则是传入的synchronized的对象实例

#### 2.原理

1. 修饰方法的时候，编译器会生成ACC_SYNCHRONIZED关键字标识
2. 当修饰代码块时候，会依赖monitorenter和monitorexit
3. 在内存中，对象一般由三部分组成，分别是对象头、对象实际数据、对其填充，重点关注对象头Mark Word的信息，Mark Word会记录对象关于锁的信息
4. 每个对象都会有一个与之对应的moniter对象，moniter对象中存储着当前持有锁的线程以及等待锁的线程队列

#### 3.synchronized锁的优化

##### 3.1 JDK1.6之前是重量级锁，线程进入同步代码块、方法时，moniter对象就会把当前进入线程id进行存储，设置Mark Word的moniter对象地址，并把阻塞的线程存储到moniter的等待线程队列中，它加锁的依赖底层操作的系统的mutex相关指令，所以会有用户态和内核态的切换，性能损耗十分明显

##### 3.2 JDK1.6之后 引入偏向锁和轻量级锁，不依赖底层操作系统，基于jvm层面的实现加锁

Mark Word 对锁的状态记录一种4种，无锁、偏向锁、轻量级锁、重量锁

1. 偏向锁，jvm认为只有某个线程ID,只要线程来执行代码，会比对线程ID是否相等，相等则当前线程直接获取锁，执行同步代码，如果不相等，则用CAS来尝试修改当前的线程ID，如果修改CAS修改成功，怎获取锁，执行代码块
2. 轻量级锁，如果偏向锁CAS失败说明有竞争环境，则偏向锁撤销，升级为轻量级锁，在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，Lock Record会把Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象，线程执行同步代码块，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record ，假设CAS修改成功,则获取轻量级锁
3. 重量级锁，轻量级锁修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁