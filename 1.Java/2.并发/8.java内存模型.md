#### 1.为什么要有java内存模型

java为了屏蔽硬件和操作系统访问内存的各种差异，提出java内存模型的规范，保证Java程序在各种平台下内存的访问都能一样。

#### 2.Java内存模型

1. Java内存模型的抽象结构
2. happen-before规则
3. 对volatile内存语义的探讨

#### 3.Java内存模型的抽象结构：Java线程对内存数据进行交互的规范

线程之间的共享变量存储在主内存中，每个线程都有自己的私有本地内存，本地内存存储了该线程以读、写共享变量的副本，线程对变量的所有操作都必须在本地内存进行，不能直接读写主内存的变量，Java内存模型定义了8种操作来完成变量从主内存到本地内存，以及变量如果从本地内存到主内存，分别时read/load/use/assign/store/write/lock/unlock操作

![image-20231021142046106](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20231021142046106.png)

#### 4.happen-before规则：java内存模型定义的一套规则，阐述操作之间的内存可见性，八条规则

#### 5.volatile关键字：解决可见性与有序性（禁止指令重排）

volatile如果做到可见性与有序性

Java内存模型为了实现volatile有序性和可见性，定义了4种内存屏障的规范：loadload、loadStore、storeLoad、storeStore，在volatile前后加上内存屏障，使得编译器和CPU无法进行指令重排，致使有序，并且写volatile变量对其他线程可见，由Java内存模型定义的内存屏障完成，实际HotSpot虚拟机实现Java内存模型规范，汇编底层通过lock指定完成