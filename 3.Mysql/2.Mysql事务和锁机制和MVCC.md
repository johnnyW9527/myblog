#### 1.理解InnoDB引擎中的事务

事务可以使一组操作要么全部成功，要么全部失败。保证数据最终的一致性

#### 2.事务的四大特性

原子性A: 当前事务的操作要么同时成功，要么同时失败。原⼦性由undo log⽇志来保证，因为undo log记载着数据修改前的信息,⽐如我们要 insert ⼀条数据了，那undo log 会记录的⼀条对应的 delete ⽇志。我们要 update ⼀条记录时，那undo log会记录之前的「旧值」的update记录,如果执⾏事务过程中出现异常的情况，那执⾏「回滚」。InnoDB引擎就是利⽤undo log记录下的数据，来将数据「恢复」到事务开始之前

一致性C:

隔离性I:在事务「并发」执⾏时，他们内部的操作不能互相⼲扰。如果多个事务可以同时操作⼀个数据，那么就会产⽣脏读、重复读、幻读的问题,事务与事务之间需要存在「⼀定」的隔离。在InnoDB引擎中，定义了四种隔离级别供我们使⽤：read uncommit(读未提交)、read commit (读已提交)、repeatable read (可重复复读)、serializable (串⾏)

持久性D:⼀旦提交了事务，它对数据库的改变就应该是永久性的。说⽩了就是，会将数据持久化在硬盘上，⽽持久性由redo log ⽇志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「⻚」找到，然后把该⻚加载到内存中，将对应记录进⾏修改为了防⽌内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了），MySQL引⼊了redo log，内存写完了，然后会写⼀份redo log，这份redo log记载着这次在某个⻚上做了什么修改，即便MySQL在中途挂了，我们还可以根据redo log来对数据进⾏恢复，redo log 是顺序写的，写⼊速度很快。并且它记录的是物理修改（xxxx⻚做了xxx修改），⽂件的体积很⼩，恢复速度也很快

#### 3.四种隔离级别

在InnoDB引擎下，按锁的粒度分类，可以简单分为⾏锁和表锁，⾏锁实际上是作⽤在索引之上的（索引上次已经说过了，这⾥就不赘述了）。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是⾏锁），如果没有命中索引，那我们锁的就是整个索引树（表锁）⽽⾏锁⼜可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁）读锁是共享的，多个事务可以同时读取同⼀个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁

read uncommit(读未提交)：A向B转账，A执⾏了转账语句，但A还没有提交事务，B读取数据，发现⾃⼰账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多，事务B读取到了事务A还没提交的数据，这种⽤专业术语来说叫做「脏读」，对于锁的维度⽽⾔，其实就是在read uncommit隔离级别下，读不会加任何锁，⽽写会加排他锁。读什么锁都不加，这就让排他锁⽆法排它了，⽽我们⼜知道，对于更新操作⽽⾔，InnoDB是肯定会加写锁的（数据库是不可能允许在同⼀时间，更新同⼀条记录的）。⽽读操作，如果不加任何锁，那就会造成上⾯的脏读，脏读在⽣产环境下肯定是⽆法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极⼤地降低数据库性能，在MySQL InnoDB引擎层⾯，⼜有新的解决⽅案（解决加锁后读写性能问题），叫做MVCC(Multi-Version Concurrency Control)多版本并发控制

MCCC:MVCC通过⽣成数据快照（Snapshot)，并⽤这个快照来提供⼀定级别（语句级或事务级）的⼀致性读取,回到事务隔离级别下，针对于 read commit (读已提交) 隔离级别，它⽣成的就是语句级快照，⽽针对于repeatable read (可重复读)，它⽣成的就是事务级的快照,前⾯提到过read uncommit隔离级别下会产⽣脏读，⽽read commit (读已提交) 隔离级别解决了脏读。思想其实很简单：在读取的时候⽣成⼀个"版本号"，等到其他事务commit了之后，才会读取最新已commit的"版本号"数据。⽐如说：事务A读取了记录(⽣成版本号)，事务B修改了记录(此时加了写锁)，事务A再读取的时候，是依据最新的版本号来读取的(当事务B执⾏commit了之后，会⽣成⼀个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据。



read commit (读已提交) 解决了脏读，但也会有其他并发的问题。「不可重复读」：⼀个事务读取到另外⼀个事务已经提交的数据，也就是说⼀个事务可以看到其他事务所做的修改，不可重复读的例⼦：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不⼀样【危害：A每次查询的结果都是受B的影响的】

了解MVCC基础之后，就很容易想到repeatable read (可重复复读)隔离级别是怎么避免不可重复读的问题了（前⾯也提到了）repeatable read (可重复复读)隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了(commit)，也只会读取当前事务版本的数据

⽽repeatable read (可重复复读)隔离级别会存在幻读的问题，「幻读」指的是指在⼀个事务内读取到了别的事务插⼊的数据，导致前后读取不⼀致